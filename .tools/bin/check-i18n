#!/usr/bin/env php
<?php

/**
 * @author Thomas Blum
 *
 * This command checks for removable keys in i18n .lang files.
 *
 * Examples:
 *
 * bin/check-i18n
 * bin/check-i18n core
 * bin/check-i18n -addonName-
 */

unset($REX);
$REX['REDAXO'] = true;
$REX['HTDOCS_PATH'] = './';
$REX['BACKEND_FOLDER'] = 'redaxo';
$REX['LOAD_PAGE'] = false;

require $REX['BACKEND_FOLDER'] . '/src/core/boot.php';
require $REX['BACKEND_FOLDER'] . '/src/core/packages.php';

// avoid PREG_JIT_STACKLIMIT_ERROR, changelog parts can be long
ini_set('pcre.jit', 0);

/**
 * @package redaxo\core
 *
 * @internal
 */
class rex_path_reflector {
    private $path;

    public function __construct($path)
    {
        $path = str_replace(['\\', '/'], '/', $path);
        $this->path = $path;
    }

    public function isCorePath() {
        return strpos($this->path, 'core/') !== false;
    }

    public function isAddonPath() {
        return strpos($this->path, 'addons/') !== false && !$this->isPluginPath();
    }

    public function isPluginPath() {
        return strpos($this->path, 'plugins/') !== false;
    }

    public function getPackageName() {
        if ($this->isAddonPath()) {
            preg_match('{.+/addons/([^/]+)/.+}', $this->path, $matches);
            return $matches[1];
        } elseif ($this->isPluginPath()) {
            preg_match('{.+/addons/.+/plugins/([^/]+)/}', $this->path, $matches);
            return $matches[1];
        } else {
            var_dump($this->path);
            throw new Exception('not a package');
        }
    }
}

class rex_check_i18n
{
    /**
     * @var array<string, int> key=lang-key, value=1
     */
    private $i18nInUse = [];
    /**
     * @var array<string, string>
     */
    private $i18nMsgCore = [];
    /**
     * @var array<string, array<string, string>>
     */
    private $i18nMsgPackages = [];

    public function __construct()
    {
    }

    private function parse()
    {
        static $seen = array();

        $files = rex_finder::factory(rex_path::src())->recursive()->filesOnly()->ignoreFiles(['.*']);
        /** @var \SplFileInfo $file */
        foreach ($files as $file) {
            $filepath = $file->getPathname();

            if (in_array($file->getExtension(), ['lang', 'css', 'js', 'gif', 'jpg', 'jpeg', 'png', 'svg', 'xml'])) {
                continue;
            }

            $searchCore = function($content){
                foreach($this->i18nMsgCore as $msgKey => $file) {
                    if (strpos($content, $msgKey) !== false) {
                        $this->i18nInUse[$msgKey] = 1;
                        unset($this->i18nMsgCore[$msgKey]);
                    }
                }
            };
            $searchPackage = function($packageName, $content) use (&$seen){
                if (!isset($this->i18nMsgPackages[$packageName])) {
                    if (!isset($seen[$packageName])) {
                        echo $packageName.': package ohne lang/'."\n";
                        $seen[$packageName] = true;
                    }
                    return;
                }

                foreach($this->i18nMsgPackages[$packageName] as $msgKey => $file) {
                    if (strpos($content, $msgKey) !== false) {
                        $this->i18nInUse[$msgKey] = 1;
                        unset($this->i18nMsgPackages[$packageName][$msgKey]);
                    }
                }
            };

            $pathReflector = new rex_path_reflector($filepath);
            if ($pathReflector->isCorePath()) {
                $content = rex_file::get($filepath);
                $searchCore($content);
            } elseif ($pathReflector->isAddonPath()) {
                $addonName = $pathReflector->getPackageName();

                $content = rex_file::get($filepath);
                $searchCore($content);
                $searchPackage($addonName, $content);
            } elseif ($pathReflector->isPluginPath()) {
                $pluginName = $pathReflector->getPackageName();

                $content = rex_file::get($filepath);
                $searchCore($content);
                $searchPackage($pluginName, $content);
            }
        }
    }

    private function loadI18n()
    {
        $files = rex_finder::factory(rex_path::src())->recursive()->filesOnly()->ignoreFiles(['.*']);
        /** @var \SplFileInfo $file */
        foreach ($files as $file) {
            $filepath = $file->getPathname();
            if ('lang' === $file->getExtension()) {
                $relfector = new rex_path_reflector($filepath);

                if ($relfector->isCorePath()) {
                    $content = rex_file::get($filepath);
                    if (preg_match_all('/^([^=\s]+)\h*=\h*(\S.*)(?<=\S)/m', $content, $matches, PREG_SET_ORDER)) {
                        foreach ($matches as $match) {
                            $this->i18nMsgCore[$match[1]] = $file->getPath();

                        }
                    }
                } else {
                    $packageName = $relfector->getPackageName();

                    $content = rex_file::get($filepath);
                    if (preg_match_all('/^([^=\s]+)\h*=\h*(\S.*)(?<=\S)/m', $content, $matches, PREG_SET_ORDER)) {
                        foreach ($matches as $match) {
                            $this->i18nMsgPackages[$packageName][$match[1]] = $file->getPath();
                        }
                    }

                }
            }
        }
    }

    private function modify()
    {
        $unused = [];
        foreach ($this->i18nMsg as $i18nKey => $langDir) {
            if (!isset($this->i18nInUse[$i18nKey])) {
                foreach ($this->i18nInUse as $inUseKey => $inUseValue) {
                    if ('addon_'.$inUseKey === $i18nKey ||
                        'plugin_'.$inUseKey === $i18nKey ||
                        'package_'.$inUseKey === $i18nKey) {
                        continue 2;
                    }

                    if (false !== strpos($inUseKey, '<regexVar>')) {
                        $pattern = '@^'.str_replace('<regexVar>', '[$a-zA-Z0-9]*', $inUseKey).'$@';
                        if (preg_match($pattern, $i18nKey)) {
                            continue 2;
                        }
                    }
                }
                $unused[$langDir][] = $i18nKey;
            }
        }

        foreach ($unused as $langDir => $i18nKeys) {
            $langFiles = rex_finder::factory($langDir)->recursive()->filesOnly()->ignoreFiles(['.*']);
            foreach ($langFiles as $langFile) {
                $content = rex_file::get($langFile);

                // Leere Zeilen w√ºrden verloren gehen
                // if (preg_match_all('/^([^=\s]+)\h*=\h*(\S.*)(?<=\S)/m', $content, $matches, PREG_SET_ORDER)) {
                //     print_r($matches);
                // }

                $newContent = [];
                $lines = explode("\n", $content);
                foreach ($lines as $line) {
                    $parts = explode('=', $line);

                    if (in_array(trim($parts[0]), $i18nKeys)) {
                        continue;
                    }

                    $newContent[] = $line;
                }
                rex_file::put($langFile, implode("\n", $newContent));
            }
        }
    }

    public function check()
    {
        $this->loadI18n();
        $this->parse();
        dump("-- un-used count --");
        dump("core: " .count($this->i18nMsgCore));
        dump("packages: ". count($this->i18nMsgPackages));
        exit();
        $this->modify();
    }
}

$check = new rex_check_i18n();
$check->check();
